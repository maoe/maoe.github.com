<!DOCTYPE html>
<head><meta charset="utf-8"></meta><title>Gists</title></head><body><h1 id="my-gists">My gists</h1>
<h2 id="sexy-types">Sexy types</h2>
<ul>
<li><a href="https://gist.github.com/1173157">Effects of <code>MonoLocalBinds</code></a></li>
<li><a href="https://gist.github.com/1173132">Scoped type variables and <code>asTypeOf</code></a></li>
<li><a href="https://gist.github.com/1172522">Encoding GADTs into leibniz equality</a></li>
<li><a href="https://gist.github.com/1170450">Encoding type classes into records</a></li>
<li><a href="https://gist.github.com/953891">GADTs + <code>QuickCheck</code></a></li>
<li><a href="https://gist.github.com/901995">An church-encoding of lists and tuples</a></li>
<li><a href="https://gist.github.com/858876">MTPCs + fundeps and type families are type functions</a></li>
<li><a href="https://gist.github.com/807969">Existentials in UHC docs</a></li>
</ul>
<h2 id="monads-and-comonads">Monads and comonads</h2>
<ul>
<li><a href="https://gist.github.com/949795">“A Neighborhood of Infinity: The Mother of all monads”</a></li>
<li><a href="https://gist.github.com/901934">Examples of Comonads</a></li>
</ul>
<h2 id="performance-optimizations">Performance &amp; optimizations</h2>
<ul>
<li><a href="https://gist.github.com/1215660">An efficient <code>chop</code></a></li>
<li><a href="https://gist.github.com/1199798">A worker/wrapper transformations</a></li>
<li><a href="https://gist.github.com/949699">Optimizing monads using CPS transformations</a></li>
</ul>
<h2 id="language-extensions">Language extensions</h2>
<ul>
<li><a href="https://gist.github.com/447680">How to use view patterns</a></li>
</ul>
<h2 id="generic-programming">Generic programming</h2>
<ul>
<li><a href="https://gist.github.com/1111300">A zipper for <code>Tree a</code></a></li>
<li><a href="https://gist.github.com/1106344">“From walking to zipping”</a></li>
<li><a href="https://gist.github.com/1073777">Generic addition to a tuple</a></li>
</ul>
<h2 id="others">Others</h2>
<ul>
<li><a href="https://gist.github.com/1182930">unsafeInterleaveIO</a></li>
<li><a href="https://gist.github.com/1161569">Breaking referential transparency in Haskell</a></li>
<li><a href="https://gist.github.com/1143968">How to use hamlet’s conditionals</a></li>
<li><a href="https://gist.github.com/1119593">A parser for GHC profiling reports</a></li>
<li><a href="https://gist.github.com/988361"><code>unsafeGetDirectoryContents</code></a></li>
<li><a href="https://gist.github.com/984378"><code>unfoldrM</code> + lazy I/O + she</a></li>
<li><a href="https://gist.github.com/982363"><code>unsafeInterleaveIO</code></a></li>
<li><a href="https://gist.github.com/928523">Coq tutorial chapter 2 in Haskell</a></li>
<li><a href="https://gist.github.com/844935">An escapable <code>foldl</code>, which was quoted from “Invertible Syntax Descriptions: Unifying Parsing and Pretty Printing”</a></li>
<li><a href="https://gist.github.com/819685">Testing a polymorphic function with <code>QuickCheck</code></a></li>
<li><a href="https://gist.github.com/784011">Fibonacci numbers in terms of <code>StreamProc</code></a></li>
<li><a href="https://gist.github.com/574709">How to use unfoldM</a></li>
<li><a href="https://gist.github.com/546987">Bi-foldr</a></li>
<li><a href="https://gist.github.com/171132">Functional bananas (foobar-morphisms)</a></li>
</ul>
<h2 id="other-languages">Other languages</h2>
<ul>
<li><a href="https://gist.github.com/997989">A proof of (∃x.P(x)) → Q ⇔ ∀x.(P(x) → Q)</a></li>
<li><a href="https://gist.github.com/475235">How to use <code>sys/resource.h</code></a></li>
<li><a href="https://gist.github.com/473497">Asynchronous DNS resolver in Scala</a></li>
</ul></body>